<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - unreal bloom selective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<!-- <button>click me</button> -->
		<div id="overlay">
			<img src="./Group 96.png" alt="">
			<button id="startButton">Play</button>
		</div>
		<script id="vertexShader2" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 vPosition;
			varying vec3 vNormal;
			uniform float time;
			uniform vec2 u_mouse;
			uniform vec3 color1;
			uniform vec3 color2;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  vPosition = position;
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				  }
		  </script>
		  <script id="fragmentShader2" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 vPosition;
			varying vec3 vNormal;
			uniform float time;
			uniform vec2 u_mouse;
			//uniform vec3 color1;
		//	uniform vec3 color2;
			

			
			void main() {
		


			vec3 color1 = vec3(0.729,0.796,0.196);
			vec3 color2 = vec3(0.459,0.518,0.);
				
					vec3 color3 = vec3(0.957,0.612,0.722);
					vec3 color4 = vec3(0.992,0.424,0.169);

					vec3 color5 = vec3(0.957,0.612, 0.722);
					vec3 color6 = vec3(0.996,0.416, 0.153);
	
				float pct = abs(sin(time*1.));
				vec3 colorMix1 = vec3(0.0);
				vec3 colorMix2 = vec3(0.0);
				vec3 colorMix3 = vec3(0.0);
				float center = distance(1. - vUv, vec2(0.5));



				color1.r += abs(0.15 - center);
				color1.g += abs(0.15 - center);
				color1.b += abs(0.15 - center);


				color2.r += abs(0.5 - center);
				color2.g += abs(0.15 - center);
				color2.b += abs(0.15 - center);



				color3.r += abs(0.15 - center);
				color3.g += abs(0.15 - center);
				color3.b += abs(0.15 - center);


				color4.r += abs(0.15 - center);
				color4.g += abs(0.15 - center);
				color4.b += abs(0.15 - center);
				//colorMix1 = mix(color1, color2, vUv.y);
				colorMix1 = mix(color1, color2, vUv.y);

				
				
			
				
				colorMix2 = mix(color3, color4, vUv.y);	

				colorMix3 = mix(color5, color6, vUv.y);	

				
				vec3 tmp = mix(colorMix1, colorMix2, pct);


				gl_FragColor = vec4(mix(colorMix1, colorMix2, pct), 1.0);
				//gl_FragColor = vec4(mix(tmp, colorMix3, pct), 1.0);
				
			}
		  </script>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>


		<script id="vertexShader3" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform float width;
			uniform float height;
			uniform vec3 color1;
			uniform vec3 color2;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  newposition = position;
			  x = position.x / 250.0;
			  y = position.y / 250.0;
	  
			 // newposition.z += 1.05*sin(newposition.y*20. + random + newposition.x*random*0.05);
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(newposition, 1.0);
				  }
		  </script>
		  <script id="fragmentShader3" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			 varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform vec3 color1;
			uniform vec3 color2;
			float plot(vec2 coord, float pct){
			  return  smoothstep( pct-0.260, pct, coord.y) -
					  smoothstep( pct, pct+0.068, coord.y);
			}
			void main() {
			vec2 coord = vUv.xy;
			vec3 color = vec3(0.0);
	  
	  
	  
			//color = mix(color1, color2, 2.3 -  vUv.y*1.25);
			color = mix(color1, color2, 1.7 -  vUv.y*2.5);
	  
	  
			gl_FragColor = vec4(color, 1.0);
	  
			
	  
	  
	  
		
	  
			}
		  </script>



		  
		<script id="vertexShader4" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform float width;
			uniform float height;
			uniform vec3 color1;
			uniform vec3 color2;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  newposition = position;
			  x = position.x / 250.0;
			  y = position.y / 250.0;
	  
			 // newposition.z += 1.05*sin(newposition.y*20. + random + newposition.x*random*0.05);
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(newposition, 1.0);
				  }
		  </script>
		  <script id="fragmentShader4" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			 varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform vec3 color1;
			uniform vec3 color2;
			float plot(vec2 coord, float pct){
			  return  smoothstep( pct-0.260, pct, coord.y) -
					  smoothstep( pct, pct+0.068, coord.y);
			}
			void main() {
			vec2 coord = vUv.xy;
			vec3 color = vec3(0.0);
	  
	  
	  
			//color = mix(color1, color2, 2.3 -  vUv.y*1.25);
			color = mix(color1, color2, 1.7 -  vUv.y*2.5);
	  
	  
			gl_FragColor = vec4(color, 1.0);
	  
			
	  
	  
	  
		
	  
			}
		  </script>


		  <script id="vertexShader5" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform float width;
			uniform float height;
			uniform vec3 color1;
			uniform vec3 color2;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  newposition = position;
			  x = position.x / 250.0;
			  y = position.y / 250.0;
	  
			 // newposition.z += 1.05*sin(newposition.y*20. + random + newposition.x*random*0.05);
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(newposition, 1.0);
				  }
		  </script>
		  <script id="fragmentShader5" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			 varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform vec3 color1;
			uniform vec3 color2;
			float plot(vec2 coord, float pct){
			  return  smoothstep( pct-0.260, pct, coord.y) -
					  smoothstep( pct, pct+0.068, coord.y);
			}
			void main() {
			vec2 coord = vUv.xy;
			vec3 color = vec3(0.0);
	  
	  
	  
			//color = mix(color1, color2, 2.3 -  vUv.y*1.25);
			color = mix(color1, color2, 1.7 -  vUv.y*2.5);
	  
	  
			gl_FragColor = vec4(color, 1.0);
	  
			
	  
	  
	  
		
	  
			}
		  </script>
		  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.0/gsap.min.js"></script>
		<script type="module">

			import * as THREE from 'https://threejs.org/build/three.module.js';

			import { GUI } from 'https://threejs.org/examples/jsm/libs/dat.gui.module.js';

			import { OrbitControls } from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';
			import { EffectComposer } from 'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from 'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
			import { ShaderPass } from 'https://threejs.org/examples/jsm/postprocessing/ShaderPass.js';
			import { UnrealBloomPass } from 'https://threejs.org/examples/jsm/postprocessing/UnrealBloomPass.js';
			import { GLTFLoader } from 'https://threejs.org/examples/jsm/loaders/GLTFLoader.js';

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', 	setupScene );
			
			const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;
			let analyser;
			let sizeVal = 0;
			let textureCube;
			let mixer;
			const bloomLayer = new THREE.Layers();
			bloomLayer.set( BLOOM_SCENE );
			let sphere;
			let movableObjs = [];
			let uniforms2, uniforms3, uniforms4, sphere_a, helper, helper2, uniforms5, sphere_b;
			let bottle2, bottle3, orbit, pointlight3, mediaElement, directionalLight2, directionalLight1, directionalLight3, directionalLight4, helper3, helper4;
			const clock = new THREE.Clock();
			const mouse = new THREE.Vector2();
			const target = new THREE.Vector2();
			const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );
			const params = {
				exposure: 1,
				bloomStrength: 0.5,
				bloomThreshold: 0,
				bloomRadius: 0,
				scene: "Scene only"
			};

			const darkMaterial = new THREE.MeshBasicMaterial( { color: "black" } );
			const materials = {};

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild( renderer.domElement );

			const scene = new THREE.Scene();

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			// camera.position.set( 0, 0, 20 );
			camera.position.set(0, 0.6, -28);
			camera.position.z = 25;
		//	camera.lookAt( 0, 0, 0 );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			//controls.minDistance = 1;
			//controls.maxDistance = 25;
			controls.enablePan = false;
			controls.enableZoom = false;
			controls.minPolarAngle = (Math.PI / 2) - 0.1; // radians
		  		controls.maxPolarAngle = (Math.PI / 2) - 0.1; // radians
//controls.target.set(-1,0,10);
			controls.enableDamping = true;
			//controls.dampingFactor =  0.05;
			controls.dampingFactor =  0.01;
			
			controls.addEventListener( 'change', render );
			controls.update();	
			// scene.add( new THREE.AmbientLight( 0x404040, 1 ) );

			const light = new THREE.AmbientLight( 0xc30037, 5 ); // soft white light
			scene.add( light );

			const renderScene = new RenderPass( scene, camera );

			const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
			bloomPass.threshold = params.bloomThreshold;
			bloomPass.strength = params.bloomStrength;
			bloomPass.radius = params.bloomRadius;

			const bloomComposer = new EffectComposer( renderer );
			bloomComposer.renderToScreen = false;
			bloomComposer.addPass( renderScene );
			bloomComposer.addPass( bloomPass );

			const finalPass = new ShaderPass(
				new THREE.ShaderMaterial( {
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} ), "baseTexture"
			);
			finalPass.needsSwap = true;

			const finalComposer = new EffectComposer( renderer );
			finalComposer.addPass( renderScene );
			finalComposer.addPass( finalPass );

			const raycaster = new THREE.Raycaster();


			// window.addEventListener( 'pointerdown', onPointerDown );
			// window.addEventListener( 'mousemove', onPointerDown );


			var colorparams = {
               
              //  lightcolor: 0xc30037,  
                lightcolor: 0xdd0006,  // ცისფერი
				lightcolor2: 0x21f5e3, // წითელი
				intensity: 7,
				intensity2: 7,
				intensity3: 1.2,
				intensity4: 1.2,
				showFront: false,
				showFront2: false,
            };

			// const gui = new GUI();

			// 	// gui.add(pointLight, 'intensity').min(0.0).max(10.0).step(0.1);
			// 	gui.add( colorparams, 'showFront' ).name( 'წინა და უკანა განათება და ჰელფერები' ).onChange(function (e) {
			// 		directionalLight4.visible = !directionalLight4.visible;
			// 		directionalLight3.visible = !directionalLight3.visible;
			// 		helper4.visible = !helper4.visible;
			// 		helper3.visible = !helper3.visible;
       		// 	 });
			// 		gui.add( colorparams, 'showFront2' ).name( 'გვერდების ჰელფერები' ).onChange(function (e) {
				
			// 		helper.visible = !helper.visible;
			// 		helper2.visible = !helper2.visible;
       		// 	 });
			// 	gui.add(colorparams, 'intensity', 0, 50).name('მარჯვენა-intensity').onChange(function (e) {
			// 		directionalLight1.intensity = e;
			
       		// 	 });
			
			// 	gui.add(colorparams, 'intensity', 0, 50).name('მარცხენა-intensity').onChange(function (e) {
            // directionalLight2.intensity = e;
           
       		// 	 });
			// 		gui.add(colorparams, 'intensity', 0, 50).name('წინა-intensity').onChange(function (e) {
           
            // directionalLight4.intensity4 = e;
       		// 	 });

			// 		gui.add(colorparams, 'intensity', 0, 50).name('უკანა-intensity').onChange(function (e) {
				
			// 	directionalLight3.intensity3 = e;
			// 	});
			// 	var colorFolder = gui.addFolder('Light Colour');
			

				
			// 	colorFolder.addColor( colorparams, 'lightcolor' )
            //     .name('მარჯვენა-light')
            //     .listen()
            //     .onChange( function() { 
			// 		directionalLight1.color.set( colorparams.lightcolor); 
			// 		directionalLight3.color.set( colorparams.lightcolor); 
			// 	} );  
				
			// 	colorFolder.addColor( colorparams, 'lightcolor2' )
            //     .name('მარცხენა-light')
            //     .listen()
            //     .onChange( function() { 
			// 		directionalLight2.color.set( colorparams.lightcolor2);  
			// 		directionalLight4.color.set( colorparams.lightcolor2);  
				
				
			// 	} );  
            // colorFolder.open();
		
			render();


			// const folder = gui.addFolder( 'Bloom Parameters' );

			// folder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

			// 	renderer.toneMappingExposure = Math.pow( value, 4.0 );
			// 	render();

			// } );

			// folder.add( params, 'bloomThreshold', 0.0, 1.0 ).onChange( function ( value ) {

			// 	bloomPass.threshold = Number( value );
			// 	render();

			// } );

			// folder.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {

			// 	bloomPass.strength = Number( value );
			// 	render();

			// } );

			// folder.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

			// 	bloomPass.radius = Number( value );
			// 	render();

			// } );

		

			// function onPointerDown( event ) {

			// 	event.preventDefault();

			// 	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			// 	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			// 	raycaster.setFromCamera( mouse, camera );
			// 	const intersects = raycaster.intersectObjects( scene.children );
			// 	if ( intersects.length > 0 ) {

			// 		const object = intersects[ 0 ].object;
			// 		// object.layers.toggle( BLOOM_SCENE );
			// 			object.layers.enable( BLOOM_SCENE );
			// 		render();

			// 	}

			// }

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				bloomComposer.setSize( width, height );
				finalComposer.setSize( width, height );
				windowHalf.set( width / 2, height / 2 );

				render();

			};

			function setupScene() {
				const overlay = document.getElementById( 'overlay' );
				overlay.remove();
				scene.traverse( disposeMaterial );
				scene.children.length = 0;
			
					
				
				const listener = new THREE.AudioListener();

				const audio = new THREE.Audio( listener );
				const file = './funk.mp3';

				if ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {

					const loader = new THREE.AudioLoader();
					loader.load( file, function ( buffer ) {
						// audio.setRefDistance( 2000 );
						audio.setBuffer( buffer );
						audio.setLoop( true );
						audio.onEnded(audio.play())
					
					audio.play();
					
				
		
			
					
					
					} );

				} else {

					mediaElement = new Audio( file );
					
					audio.setMediaElementSource( mediaElement );
				
					mediaElement.loop = true;
				
						mediaElement.play();
				
					
			

			
					

					

				}
				audio.hasPlaybackControl = true;
			
				
				analyser = new THREE.AudioAnalyser( audio, 32768 );
			
				

			// function playSound() {
			// 	audioLoader.load("clips/theme_80.mp3", function(buffer) {
			// 		sound.setBuffer( buffer );
			// 		sound.setRefDistance( 20 );
			// 		sound.play();
			// 	});

			// 	var source = listener.context.createBufferSource();
			// 	source.connect(listener.context.destination);
			// 	source.start();
			// 	}
			// 	window.addEventListener('touchstart', playSound);
			// 	document.addEventListener('click', playSound);

				// setInterval(() => {
				// 	// console.log(Math.max(...analyser.data))
				// 	console.log(sizeVal)
				// 	// sizeVal = Math.max(...analyser.data);
				
				// 	// console.log(analyser)
				// }, 1000);

				

				




				const geometry = new THREE.SphereGeometry( 0.2, 32, 32 );
				uniforms3 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						color1: { type: "c", value: new THREE.Color(0xfdcf18)  },
						color2: { type: "c", value: new THREE.Color(0xff760f)  },
						width: {
							type: "f",
							value: window.innerWidth
						},
						height: {
							type: "f",
							value: window.innerHeight
						},
						random: {
						value: Math.random()*2.5
						}
						};
				for ( let i = 0; i < 100; i ++ ) {
					
					// const color = new THREE.Color();
					// color.setHSL( Math.random(), 0.8, Math.random() * 0.2 + 0.05 );

					const material = new THREE.ShaderMaterial({
          side: THREE.DoubleSide,
          uniforms: uniforms3,
          vertexShader: document.getElementById("vertexShader3").textContent,
          fragmentShader: document.getElementById("fragmentShader3").textContent,
        });
					
					sphere = new THREE.Mesh( geometry, material );
			// // numbers between 20-60		Math.random() * (60 - 20) + 20;
			// 		sphere.position.x = -Math.floor(Math.random() * 6) + 100; 
			// 		sphere.position.y = Math.floor(Math.random() * 20); 
			// 		sphere.position.z = Math.random() * 30;
			// 		sphere.position.normalize().multiplyScalar( Math.random() * 400 );
			// 		// sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
			
			sphere.position.x = Math.random() * 10 - 5;
					sphere.position.y = Math.random() * 10 - 5;
					sphere.position.z = Math.random() * 10 - 5;
					sphere.position.normalize().multiplyScalar( Math.random() * 30.0 + 8.0 );
					sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
					sphere.castShadow = false; //default is false
					sphere.receiveShadow = false; //default
					// sphere.material.specular.setHex(0x000000);
					scene.add( sphere );
					movableObjs.push(sphere);
					// console.log(movableObjs)
					// console.log(scene.children)
					sphere.layers.enable( BLOOM_SCENE );

				}




				
				const geometry_a = new THREE.SphereGeometry( 0.2, 32, 32 );
				uniforms4 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						color1: { type: "c", value: new THREE.Color(0xf49cb8)  },
						color2: { type: "c", value: new THREE.Color(0xe63296)  },
						width: {
							type: "f",
							value: window.innerWidth
						},
						height: {
							type: "f",
							value: window.innerHeight
						},
						random: {
						value: Math.random()*2.5
						}
						};


				for ( let i = 0; i < 100; i ++ ) {
					
					

					const material_a = new THREE.ShaderMaterial({
          side: THREE.DoubleSide,
          uniforms: uniforms4,
          vertexShader: document.getElementById("vertexShader4").textContent,
          fragmentShader: document.getElementById("fragmentShader4").textContent,
        });
					
					sphere_a = new THREE.Mesh( geometry_a, material_a );
			
			
			sphere_a.position.x = Math.random() * 10 - 5;
					sphere_a.position.y = Math.random() * 10 - 5;
					sphere_a.position.z = Math.random() * 10 - 5;
					sphere_a.position.normalize().multiplyScalar( Math.random() * 30.0 + 8.0 );
					sphere_a.scale.setScalar( Math.random() * Math.random() + 0.5 );
					sphere_a.castShadow = false; //default is false
					sphere_a.receiveShadow = false; //default
					
					scene.add( sphere_a );
					movableObjs.push(sphere_a);
					
					sphere_a.layers.enable( BLOOM_SCENE );

				}





					
				const geometry_b = new THREE.SphereGeometry( 0.2, 32, 32 );
				uniforms5 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						color1: { type: "c", value: new THREE.Color(0xf49cb8)  },
						color2: { type: "c", value: new THREE.Color(0xe63296)  },
						width: {
							type: "f",
							value: window.innerWidth
						},
						height: {
							type: "f",
							value: window.innerHeight
						},
						random: {
						value: Math.random()*2.5
						}
						};

						
				for ( let i = 0; i < 100; i ++ ) {
					
					

					const material_b = new THREE.ShaderMaterial({
          side: THREE.DoubleSide,
          uniforms: uniforms5,
          vertexShader: document.getElementById("vertexShader4").textContent,
          fragmentShader: document.getElementById("fragmentShader4").textContent,
        });
					
					sphere_b = new THREE.Mesh( geometry_b, material_b );
			
			
			sphere_b.position.x = Math.random() * 10 - 5;
			sphere_b.position.y = Math.random() * 10 - 5;
			sphere_b.position.z = Math.random() * 10 - 5;
			sphere_b.position.normalize().multiplyScalar( Math.random() * 30.0 + 8.0 );
			sphere_b.scale.setScalar( Math.random() * Math.random() + 0.5 );
			sphere_b.castShadow = false; //default is false
			sphere_b.receiveShadow = false; //default
					
					scene.add( sphere_b );
					movableObjs.push(sphere_b);
					
					//sphere_b.layers.enable( BLOOM_SCENE );

				}
				

				// aq 80, 80, 200 iyo
				var geometryplane = new THREE.SphereGeometry(25, 25, 200);

						uniforms2 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						// color1: { type: "c", value: new THREE.Color(0xbacb32)  },
						// color2: { type: "c", value: new THREE.Color(0x758400)  },
						};

						var materialplane = new THREE.ShaderMaterial({
						// side: THREE.DoubleSide,
						side: THREE.BackSide,
						uniforms: uniforms2,
						vertexShader: document.getElementById("vertexShader2").textContent,
						fragmentShader: document.getElementById("fragmentShader2").textContent,
						});

						var mesh2 = new THREE.Mesh(geometryplane, materialplane);
						scene.add(mesh2);
						const light = new THREE.AmbientLight( 0xffffff); // soft white light
						scene.add( light );

						directionalLight1 = new THREE.DirectionalLight( 0xe40340, 25.3 );
						directionalLight1.position.set( 14, 2, -3 );
					scene.add( directionalLight1 );

			


				



					directionalLight2 = new THREE.DirectionalLight(0x04b8f5, 25.3);
				//	directionalLight2.position.set(-18, 2, 3);
				directionalLight2.position.set(-18, 2, 3);
				
					scene.add(directionalLight2);



				directionalLight3 = new THREE.DirectionalLight( 0xdd0006, 3.2 );
						directionalLight3.position.set( 0, 2, -13 );
					scene.add( directionalLight3 );

			


					
					directionalLight4 = new THREE.DirectionalLight(0x21f5e3, 3.2);
					directionalLight4.position.set(0, 2, 13);

					scene.add(directionalLight4);

				
					
// 					const HemisphereLight = new THREE.HemisphereLight(0x04b8f5,0xe40340, 15.5);
// 					HemisphereLight.position.set(-20, -1, 3);
					

// 					scene.add(HemisphereLight);

// 					const HemisphereLighthelper = new THREE.HemisphereLightHelper( HemisphereLight, 5 );
// scene.add( HemisphereLighthelper );
			
const cubeloader = new THREE.CubeTextureLoader();
				cubeloader.setPath( './glbbottle/bottleenv/' );

				textureCube = cubeloader.load( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );
				textureCube.encoding = THREE.sRGBEncoding;

				
// const geometrytest = new THREE.SphereGeometry( 3, 232, 232 );
// const materialtest = new THREE.MeshPhongMaterial( {color: 0xffff00, shininess: 60.2} );
// materialtest.envMap = textureCube;
// materialtest.needsUpdate = true;
// const spheretest = new THREE.Mesh( geometrytest, materialtest );
// scene.add( spheretest );
		

					const sphereSize = 1;
			
				
		

					helper = new THREE.DirectionalLightHelper( directionalLight1, 5 );
						scene.add( helper );

					helper2 = new THREE.DirectionalLightHelper( directionalLight2, 5 );
						scene.add( helper2 );



						helper3 = new THREE.DirectionalLightHelper( directionalLight3, 5 );
						scene.add( helper3 );

					helper4 = new THREE.DirectionalLightHelper( directionalLight4, 5 );
						scene.add( helper4 );


						if(!colorparams.showFront){
				directionalLight4.visible = false;
				directionalLight3.visible = false;
				helper4.visible = false;
				helper3.visible = false;
			} else {
				directionalLight4.visible = true;
				directionalLight3.visible = true;
				helper4.visible = true;
				helper3.visible = true;
			}

			if(!colorparams.showFront2){
			
				helper.visible = false;
				helper2.visible = false;
			} else {
		
				helper.visible = true;
				helper2.visible = true;
			}



						const loader = new GLTFLoader().setPath("./glbbottle/");
				
						// console.log(texture)
							loader.load("jujuna.glb", function (gltf) {
								bottle2 = gltf.scene;
								bottle2.rotation.y = -2.0;
								//bottle2.rotation.y = -28.6;
								bottle2.position.y = -8.2;
								bottle2.position.x = 7.8;
								bottle2.receiveShadow = false;
								bottle2.traverse(function (child) {
								if (child.isMesh) {
									child.receiveShadow = false;
									child.castShadow = false;
									child.material.envMap = textureCube;
									child.material.envMapIntensity = 20.5;
								}
								});
								console.log(gltf)
								bottle2.scale.set(50,50,50);
								scene.add(bottle2);
								//camera.position.set(-22.225244871783282, 2.4965541132930738, 11.187748117859483);
								camera.position.set(-17.697619093236263, -3.4965541132930738, 0);
								//camera.lookAt(bottle2.position);
							//controls.target.copy( bottle2.position );
							controls.target.set( 7.8, -2.2, 0 );
								controls.update();
								// console.log(bottle2)
							mixer = new THREE.AnimationMixer( gltf.scene );
							let firstAction = mixer.clipAction(gltf.animations[0]);
							console.log(bottle2)
							//firstAction.setLoop(THREE.LoopRepeat, 25);	
							
							firstAction.play();
							animate();
							// firstAction.play();
							// mixer.addEventListener('finished', (e) => { 
							// 	console.log("hewy")


							// })
								//render();
							
							});
							
							document.addEventListener("click", () => {
								//console.log(camera.position)
								//console.log(bottle2.position)
							})
							// loader.load("jujuna.glb", function (gltf) {
							// 	bottle3 = gltf.scene;
							// 	bottle3.rotation.y = -0.1;
							// 	bottle3.rotation.z = -0.2;


							// 	bottle3.position.y = -8.3;
							// 	bottle3.position.z = -2.7;

								
							// 	bottle3.position.x = 1.2 - 2.7;
							// 	bottle3.traverse(function (child) {
							// 	if (child.isMesh) {
							// 	}
							// 	});
							// 	bottle3.scale.set(50,50,50);
							// 	scene.add(bottle3);
							// 	// console.log(bottle3)
								
							// });
							console.log(uniforms3.color1.value.g)
				render();
				animate();

			}

			// document.addEventListener('mousemove', function(e){
    		// 	// let scale = -0.01;
			// 	// 	orbit.rotateY( e.movementX / 500 );
			// 	// // orbit.rotateX( e.movementY * scale ); 
			// 	// orbit.rotation.z = 0; //this is important to keep the camera level..
			// 	// camera.position.x = e.movementX / 900;
			// 	// camera.updateProjectionMatrix();
			// 	mouse.x = ( e.clientX - windowHalf.x );
			// 	mouse.y = ( e.clientY - windowHalf.y );
				
			// 	})
				
				// //the camera rotation pivot
				// orbit = new THREE.Object3D();
				// orbit.rotation.order = "YXZ"; //this is important to keep level, so Z should be the last axis to rotate in order...
				// if(bottle2) orbit.position.copy( bottle2.position );
				// scene.add(orbit );
				// orbit.add( camera );




			function disposeMaterial( obj ) {

				if ( obj.material ) {

					obj.material.dispose();

				}

			}

			function render() {
				const time = Date.now() * 0.0001;
				
				switch ( params.scene ) {

					case 'Scene only':
						renderer.render( scene, camera );
						break;
					case 'Glow only':
						renderBloom( false );
						break;
					case 'Scene with Glow':
					default:
						// render scene with bloom
						renderBloom( true );

						// render the entire scene, then render bloom scene on top
						finalComposer.render();
						break;

				}
				// pointlight3.position.x = Math.cos( time * 20.7 ) * 285;
				for (let i = 0; i < movableObjs.length; i++) {
			
					// const sphere = movableObjs[ i ];
					// sphere.position.x = Math.cos( time + i * 100.7 ) * 11;
					// sphere.position.y = Math.sin( time + i * 3.1 ) * 11;
					// sphere.position.z = Math.sin( time + i * 1.1 ) * 15;
			
					
				}
			
				

			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}

			}
			var animate = function () {
				const delta = clock.getDelta();

			if(bottle2)	mixer.update( delta );
        requestAnimationFrame(animate);
		if(analyser)	analyser.getFrequencyData();
				// sphere.rotation.x += 50;
				// target.x = ( 1 - mouse.x ) * 0.0001;
				// target.y = ( 1 - mouse.y ) * 0.0001;
				
				// camera.rotation.x += 0.13 * ( target.y - camera.rotation.x );
				// camera.rotation.y += 0.13 * ( target.x - camera.rotation.y );

				uniforms2.time.value += clock.getDelta();
				
				
			//console.log(delta)
			
			//	if(analyser)	sizeVal = Math.max(...analyser.data) / 80;
			//if(analyser)	sizeVal = analyser.data;
			const sum = analyser.data.reduce((a, b) => a + b, 0);
			const avg = (sum / analyser.data.length) || 0;
				if(analyser) sizeVal = avg / 15;

			
				


				if(sizeVal > 5.1){
			
			uniforms5.color1.value = new THREE.Color(0xbacb32);
			uniforms5.color2.value = new THREE.Color(0x758400);
					uniforms3.color1.value = new THREE.Color(0xfdcf18 );
			uniforms3.color2.value = new THREE.Color(0xff760f);
		}
		else	if(sizeVal < 4.9 && sizeVal > 4.8){
			
			uniforms4.color1.value = new THREE.Color(0xf49cb8);
			uniforms4.color2.value = new THREE.Color(0xe63296);
			// 		uniforms3.color1.value = new THREE.Color(0xfdcf18 );
			// uniforms3.color2.value = new THREE.Color(0xff760f);
		}
		
		else	if(sizeVal < 4.4 && sizeVal > 4.1){
			
			uniforms5.color1.value = new THREE.Color(0xbacb32);
			uniforms5.color2.value = new THREE.Color(0x758400);
					uniforms3.color1.value = new THREE.Color(0xfdcf18 );
			uniforms3.color2.value = new THREE.Color(0xff760f);
		}

		// 	else	if(sizeVal < 4.1 && sizeVal > 4.2){
			
		// 	// uniforms4.color1.value = new THREE.Color(0xf49cb8);
		// 	// uniforms4.color2.value = new THREE.Color(0xe63296);
		// 			uniforms3.color1.value = new THREE.Color(0xfdcf18 );
		// 	uniforms3.color2.value = new THREE.Color(0xff760f);
		// }


			else if(sizeVal < 3.8 && sizeVal > 3.5){
			
			uniforms4.color1.value = new THREE.Color(0xf49cb8);
			uniforms4.color2.value = new THREE.Color(0xe63296);
					uniforms3.color1.value = new THREE.Color(0xfdcf18 );
			uniforms3.color2.value = new THREE.Color(0xff760f);
		}





				
		
		else if(sizeVal < 3.18 && sizeVal > 3.15){
			
			uniforms5.color1.value = new THREE.Color(0xbacb32);
			uniforms5.color2.value = new THREE.Color(0x758400);
					uniforms3.color1.value = new THREE.Color(0xfdcf18 );
			uniforms3.color2.value = new THREE.Color(0xff760f);
		}

			else	if(sizeVal < 2.9 && sizeVal > 2.8){
			
					uniforms4.color1.value = new THREE.Color(0xf49cb8);
					uniforms4.color2.value = new THREE.Color(0xe63296);
							uniforms3.color1.value = new THREE.Color(0xfdcf18 );
					uniforms3.color2.value = new THREE.Color(0xff760f);
				} 
				
		
			else if(sizeVal < 2.3 && sizeVal > 2.1){
				uniforms3.color1.value = new THREE.Color(0xfdcf18 );
					uniforms3.color2.value = new THREE.Color(0xff760f);
					uniforms5.color1.value = new THREE.Color(0xbacb32);
			uniforms5.color2.value = new THREE.Color(0x758400);
					
				}
				else if(sizeVal < 1.9 && sizeVal > 1.8){
					uniforms4.color1.value = new THREE.Color(0xf49cb8);
					uniforms4.color2.value = new THREE.Color(0xe63296);
					uniforms5.color1.value = new THREE.Color(0xbacb32);
			uniforms5.color2.value = new THREE.Color(0x758400);
				}
				
			

				else if(sizeVal < 1.5 && sizeVal > 1.4){
					uniforms4.color1.value = new THREE.Color(0xf49cb8);
					uniforms4.color2.value = new THREE.Color(0xe63296);
					// 		uniforms3.color1.value = new THREE.Color(0xfdcf18 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
					uniforms5.color1.value = new THREE.Color(0xbacb32);
			uniforms5.color2.value = new THREE.Color(0x758400);
				}

			
				else if(sizeVal < 0.8 && sizeVal > 0.7){
					uniforms4.color1.value = new THREE.Color(0xf49cb8);
					uniforms4.color2.value = new THREE.Color(0xe63296);
					// 		uniforms3.color1.value = new THREE.Color(0xfdcf18 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 0.3 && sizeVal > 0.2){
					uniforms4.color1.value = new THREE.Color(0xf49cb8);
					uniforms4.color2.value = new THREE.Color(0xe63296);
					// 		uniforms3.color1.value = new THREE.Color(0xfdcf18 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 0.0 && sizeVal > 0.03){
					uniforms4.color1.value = new THREE.Color(0xf49cb8);
					uniforms4.color2.value = new THREE.Color(0xe63296);
					// 		uniforms3.color1.value = new THREE.Color(0xfdcf18 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

			
				


				


				
			
				
				else{
					gsap.to(uniforms4.color1.value, {
						duration: 0.6,
						// value: new THREE.Color(0x5c5c5c),
						r: 1.,
						g: 1.,
						b: 1.,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms4.color2.value, {
						duration: 0.6,
						r: 0.675,
						g: 0.675,
						b: 0.675,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms3.color1.value, {
						duration: 0.6,
						r: 1.,
						g: 1.,
						b: 1.,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms3.color2.value, {
						duration: 0.6,
						r: 0.675,
						g: 0.675,
						b: 0.675,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})




					gsap.to(uniforms5.color1.value, {
						duration: 0.6,
						r: 1.,
						g: 1.,
						b: 1.,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms5.color2.value, {
						duration: 0.6,
						r: 0.675,
						g: 0.675,
						b: 0.675,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})
		
		




		
				}

		

			
				
				controls.update();
				render();

			}
			

		</script>

	</body>

</html>
